user@Ubuntu:~$
user -имя пользователя
Ubuntu -имя хоста или компьютера
~ -домашний каталог
$ -обычный пользователь
# -суперпользователь root

имя_команды [опции/флаги/ключи] [параметры/аргументы]
	аргументы - объекты, над которыми мы хотимм выполнить действие

=====СМЕНА ДИРЕКТОРИЙ=====
pwd 			-текущая рабочая директория в которой мы находимся

cd / 			-перейти в корневой каталог системы
cd /home 		-перейти в папку home
cd (или cd ~) 	-перейти в домашнюю директорию пользователя

=====ОБЩИЕ КОМАНДЫ=====
whoami 	-выводит имя пользователя
clear 	-очистка рабочего пространнства
date 	-дата и время
.file 	-скрытый файл или папка

=====СПРАВКА ПО КОМАНДАМ=====
man ls 		-полный вывод информации по команде ls
пробел 		-перелистывает на другие страницы
q 			-выход из справки
ls -h (или ls --help)	-выводит краткая встроенная справка по использованию команды

ls -смотреть содержимое каталога, в котором мы находимся. выводит содержимое папок и файлов, которые находятся в папке

=====СЛУЖБЫ=====
systemd -система инициализации

типы служб:
service 	-обычная служба
target 		-группа служб

утилита SYSTEMCTL
systemctl [опции] [команда] [служба]
systemctl list-units --type service			list-units -означает просмотр служб 
UNIT 			название служб
LOAD
	loaded 	-означает что конфигурационный файл был успешно загружен
ACTIVE
	active	-означает что службы была запущена
SUB
	running	-означает что службы работает в данный момент
	exited 	-была остановлена и не используется
DESCRIPTION	-описывает работу службы

systemctl list-units --type service --state running
	--state running			показывает только работающие в данный момент службы

systemctl status networking.service
	status				-просмотр статуса службы
	networking.service -сетевая служба
	
systemctl stop networking.service		-остановить сетевую службу
systemctl start networking.service		-запустить сетевую службу

=====ТИПЫ КОМАНД=====
вводимые пользователем программы делятся на два типа:
1. внутренние команды, которые встроены в оболочку
2. внешние команды, которые не встроены в оболочку

чтобы определить тип команды (внешняя или внутренняя) необходимо ввести: type cd
cd is a shell builtin

=====ОБОЛОЧКИ=====
echo $SHELL - узнать тип оболочки
/bin/bash

ps - выводит все текущие процессы
ps -p $$ - индентификатор процесса запущенной оболочки
cat /etc/shells - вывести доступные оболочки
sh - перейти в оболочу sh 
chsh -s /bin/sh - сменить оболочу sh на постоянной основе (смена произойдет после перезапуска системы)

======ПЕРЕМЕННЫЕ======
Системные переменные предназначаются для организации системной среды и хранятся в следующих системных файлах: 
/etc/profile – переменные для интерактивных оболочек;
/etc/bash.bashrc – переменные для командных оболочек;
/etc/environment – переменные базовой среды для всех процессов.

Пользовательские переменные - переменные для своего рабочего окружения. Стандартно конфигурации пользовательского окружения хранятся в файлах:
~/.profile — инициализация доступных пользователю командных оболочек,
~/.bashrc — параметры инициализации выбранной командной оболочки для пользователя.

Временные или переменные сеанса = переменные окружения, но устанавливаемые лишь на время текущего сеанса пользователя. 

Работа с переменными окружения:
- по умолчанию любое значение переменной считает строковым
- имена переменных чувствительны к регистру
переменные бывают:
1. переменные окружения - переменные которые определены для текущенй оболочки и наследуются любыми дочерними оболчками и процессами.
2. переменные оболчки - переменные, которые содержатся исключительно в оболочке в которой они были установлены или определены.

env (или printenv) -вывести переменные окружения 
 
KEY="value" -установка временной переменной
echo $KEY -вывод значения переменной KEY
echo $BASH_VERSION - вывод информации по конкретной переменной BASH_VERSION

printenv SHELL - вывод информации по конкретной переменной SHELL
printenv | grep VAR1 - вывод информации по конкретной переменной VAR1

set -все существующие переменные оболчки
set | less -построчный вывод
set | grep VAR2 -вывод информации переменной VAR2

export VAR1=value1 - установим переменную окружения, имя VAR1 и значение value1. Расширить область видимости
VAR2=value2 - установить переменную оболочки 

~/.bashrc (или ~/.bash_profile)- файл, в котором можно сохранять пользовательские переменные. переменные сохраняются внутри оболочки и будут доступны даже после перезгрузки

/etc/profile или /etc/bash.bashrc -файл, в котором можно сохранить постоянную пользовательскую или системную переменную 

======Выполнение команды
command -o1 -o2 arg1 arg2

o1, o2 - ключи, флаги, опции, есть короткие и либо длинные, например -a и -all

ls --help - вывод справки


ls -la -кобинация двух коротких флагов
ls -l -a - другая форма записи
ls --all --inode - длинная форма записи
ls --allinode - ДЛИННЫЕ ФЛАГИ КОМБИНИРОВАТЬ НЕЛЬЗЯ!

======ПОТОКИ И ИХ ПЕРЕНАПРАВЛЕНИЕ======
stdin 0 			-стандартный поток ввода
stdout 1 			-стандартный поток вывода
stderr 2 			-стандартный поток ошибки
echo example 		-передает сразу в поток стандартного вывода переданный аргумент
echo 123 > file1 	-перенаправление "123" в файл file1. > знак перенаправления. означает, что данные будут записаны в файл, при условии что он создан. 
echo 123 >> file1 	-будет создан file1 если он не был создан, либо будет добавлена информация в конец файла, если он был создан.

cat file1 		-вывод информации, посмотреть содержимое фала file1
12134

cat > file2 	-перенаправление данных после ввода информации в file2
123
456

cat < file2 	-возьмем поток вывод из файла и выведем информацию на экран

ls /var > file3 - перенаправить результат работы комамнды в файл file3

ls /% > file3 - т.к. папки с наименованием "%" нет, то появится ошибка
ls: cannot access '/%': No such file or directory

ls /% 2 > file2 - флаг 2 позволяет перенаправить поток ошибок в файл file2

cat file1 file2 file3 > bigfile - перенаправить содержимое всех трех файлов в один большой файл bigfile


======КАНАЛЫ======
канала используются для перенаправления потока из одной программы в другую, часто используется для фильтрации, например с команддами grep и find
| - символ канала

ls | grep file - будет выведено все файлы, в названии которых есть слово file

find - команда, которая возвращает файл с передаваемым аргументом
grep - команда, которая возвращает только те строки, которые содержат регулярные выражения
регулярные выражения - определенные шаблоны для поиска строк или значений 
tee - 
tr - команда, которая находит и заменяет одну строку другой 
wc - подсчитывает символы, линии, слова
tail - выводит конец файла, по умолчанию 10 строк
head - выводит начало файла, по умолчанию 10 строк
cut - может вырезать столбец данных 
sort - сортирует данные по определенному критерию, по умолчанию будет выводить в алфавитном порядке
uniq - удалякт повторяющиеся строки в выводе
sed - Обрабатывает текст в соответствии с заданным скриптом, наиболее часто используется для замены текста в потоке
awk - может работать с текстом в соответствии с заданным скриптом, как правило очень удобен для обработки текстовых таблиц


======СКРИПТЫ НА BASH======
скрипты нужны чтобы автоматизировать какие-либо действия в системе и использовать в дальнейшем для работы 

#!/bin/bash -вначале любого скрипта необходимо указать интерпретатор, который будет выполнять данный скрипт
#! - особая комбинация символов, которая означает интерпретатор на который следует передать вывполнение ниже написанный команда, указывается путь к испольняеммому файлу нашего интепретатора, можно указывать любой интепретатор, который необходимо использовать, например если пишем скрипт на python, то указываем #!/usr/bin/python3

nano script.sh - создание файла script.sh если он ранее не был создан, либо открытие файлы для его редактирования

echo "Hello world" - вывод на экран Hello world
chmod a+x script.sh -после создания скрипта нужно назначить права на исполнение для нашего файла
чтобы запусть скрипт необходимо указать полный путь к файлу, если мы находимся в той же папке что и скрипт, то можно запустить скрипт командой 
./script.sh -запустить скрипт, иначе необходимо указывать полный путь к исполняемому файлу


string="hello world" -создание переменной string со значением hello world
string2=hello world -по умолчанию в переменные записываются строковые данные, поэтому указывать кавычки не обязательно
$string - Обращение к значение переменной происходит через знак $
echo $string -выводит на экран значение переменной string, т.е. будет выводить hello world

stringbig=$string$string2 -конкатенация двух строк и присваивание итогового значения переменной stringbig

$() -конструкция используется для присвоения переменной результата выполнения некой команды, например
string2=$(date) 

Параметры скрипта.
echo $1 $3 - внутри скрипта идет обращение к первому и третьему параметрам, соответственно чтобы их выполнить необходимо запустить команду
./sripth.sh 123 345 678
вывод будет:
123 678

ниже программа, которая выводит на экран сообщение, с просьбой ввести значение переменной var1, после ввода переменной присваивается значение и значение выводится на экран
echo "please set var1"
read var1
echo $var1

if [[ $1 > $2 ]]	условие
then 
echo $1 
else 				иначе
echo $2
fi 					завершающая конструкция, обязательно ее устанавливаем, образовано от слова final

операторы
> -больше, аналогичен оператору для чисел -gt
< -меньше, аналогичен оператору для чисел -lt
-eq -равенство (от equal)
-ne -не равенство (от not equal)

циклы
for index in $(ls) - вмесето $(ls) можно использовать ряд чисел, например 1 2 3 4 5
do
echo $index 
done	-завершающая конструкция

циклы можно прописывать в строку прямо в терминале, например:
for i in 1 2 3 4 5; do echo $i; done
1
2
3
4
5

while - условный цикл

read var
while [[$var -lt 5]]
do
echo $var
let "var=var+1" -все что в двойных кавычках воспринимается как арифмитическая операция, которая будет выполнена командой let. команда let в скриптах выполняет арифмитические действия
done

======РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ======

\	Начинаются буквенные спецсимволы, а также если нужно использовать спецсимвол в виде знака препинания.
^	Начало строки.
$	Конец строки.
*	Предыдущий символ может повторяться 0 или больше раз.
+	Предыдущий символ должен повторять 1 или больше раз.
?	Предыдущий символ может встречаться 0 или 1 раз.
{n}	(n) раз нужно повторить предыдущий символ.
{N,n}	Предыдущий символ повторяется от N до n раз.
.		Любой символ кроме перевода строки.
[az]	Любой символ, указанный в скобках.
x|y		x или y.
[^az]	Любой символ, кроме тех, что в скобках.
[a-z]	Любой символ от a до z.
[^a-z]	Любой символ которого нет в диапазоне от a до z.
\b		Граница слова с пробелом.
\B		Означает что символ должен быть внутри слова.
\d		Означает, что символ – цифра.
\D		Нецифровой символ.
\n		Перевод строки.
\s		Пробел, табуляция и так далее.
\S		Любой символ кроме пробела.
\t		Табуляция.
\v		Вертикальная табуляция.
\w		Любой буквенный, включая подчеркивание.
\W		Любой буквенный, кроме подчеркивания.
\uXXX	Символ Unicdoe.

Поиск слова, которое начинается с «с», оканчивается на «t» и может содержать один любой символ посередине в файле с именем «file1»:
$ grep "c.t" file1

Поиск слова, которое начинается с «A», оканчивается на «a» и может иметь только «r», «k» или «n» посередине в файле «file2»:
$ grep "A[rkn]a" file2

Поиск слова, начинающегося с «la» и затем включающего произвольное количество вхождений буквы «k», включая их отсутствие, в файле «file3»:
$ grep "lak*" file3
В этом случае регулярным выражением является символ «*» и означает любое повторение предыдущего символа — буквы «k» в слове, даже возможность его полного отсутствия. Т.е. под шаблон подойдут слова «lake», «la», «lakkkkk» и т.д.

touch file
	—создать file;
	
rm file
	—удалить file;
rm -r dir
	—удалить каталог dir;
	
rmdir dir
	—удалить каталог dir;

cp file1 file2
	—скопировать file1 в file2;
cp -r dir1 dir2
	—скопировать каталог dir1 в dir2. Создаст каталог dir2, если он не существует;

mv file1 file2
	—переименовать или переместить file1 в file2, если file2 — существующий каталог, то переместить file1 в каталог file2;
mv dir1 dir2
	—переименовать или переместить каталог dir1 в dir2, если dir2 — существующий каталог, то переместить dir1 в каталог dir2;

cat file
	—вывести содержимое file;

more file
	—вывести содержимое file постранично;

head file
	—вывести первые 10 строк file;

tail file
	—вывести последние 10 строк file;

wc file
	—показывает количество строк, слов, символов в файле file.

Is
	—просмотреть спискок файлов и каталогов;
Is -al
	—просмотреть форматированный список с правами доступа и скрытыми каталогами и файлами;
ls -d */
	—просмотреть список папок в текущем каталоге;
ls dirname
	—вывести содержимое каталога dirname на экран;
	
pwd
	—вывод полного пути к текущему каталогу;
cd
	—переход с текущего каталога на домашний пользовательский;
cd dir1
	—перейти в папку dir1;
cd /
	—перейти в корневой каталог;

du -h dirname
	—посмотреть размер каталога dirname;
	
find file
	—найти файл с именем file;
	
stat file1
	—получить информацию о file1 (размер файла, дата создания файла и т. д.) и проверка существования файла;
	
realpath file
	—узнать абсолютный путь к файлу file;
	
diff file1 file2
	—сравнить file1 и file2;
	s
grep text filename
	—поиск и вывод строк из файла filename, содержащих подстроку «text».

=========mkdir: СОЗДАНИЕ ПАПОК=========

mkdir new_folder
	-создать в текущей директориии папку new_folder

mkdir new_folder_1 new_folder_2 new_folder_3
	-создать в текущей директориии 3 папки

mkdir sample/new_folder_1 sample/new_folder_2
	-создать папки new_folder_1 и new_folder_2 в директории sample
